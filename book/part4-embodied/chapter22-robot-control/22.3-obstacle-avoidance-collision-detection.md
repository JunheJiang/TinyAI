# 22.3 éšœç¢ç‰©é¿éšœä¸ç¢°æ’æ£€æµ‹

## å¼•è¨€

è·¯å¾„è§„åˆ’è§£å†³äº†"å¾€å“ªèµ°"çš„é—®é¢˜,ä½†çœŸå®ä¸–ç•Œä¸­,æœºå™¨äººè¿˜ä¼šé‡åˆ°å„ç§åŠ¨æ€éšœç¢ç‰©:çªç„¶å‡ºç°çš„å® ç‰©ã€ç§»åŠ¨çš„äººã€å…¶ä»–æœºå™¨äºº...è¿™äº›éƒ½éœ€è¦å®æ—¶é¿éšœèƒ½åŠ›ã€‚å°±åƒå¼€è½¦æ—¶,å³ä½¿ä½ çŸ¥é“ç›®çš„åœ°æ€ä¹ˆèµ°,ä¹Ÿéœ€è¦éšæ—¶æ³¨æ„çªç„¶çªœå‡ºçš„è¡Œäººå’Œè½¦è¾†ã€‚

é¿éšœæ˜¯æœºå™¨äººå®‰å…¨è¿è¡Œçš„åŸºç¡€ã€‚ä¸€ä¸ªå¥½çš„é¿éšœç³»ç»Ÿä¸ä»…è¦èƒ½èº²å¼€éšœç¢ç‰©,è¿˜è¦ä¿æŒè¿åŠ¨çš„æµç•…æ€§,é¿å…æ€¥åœæ€¥è½¬ã€‚æœ¬èŠ‚å°†ä»‹ç»éšœç¢ç‰©æ£€æµ‹ã€åŠ¨æ€é¿éšœç®—æ³•å’Œç¢°æ’é¢„è­¦æœºåˆ¶ã€‚

## æ ¸å¿ƒæ¦‚å¿µ

### æ¦‚å¿µ1:éšœç¢ç‰©è¡¨ç¤ºæ–¹æ³•

**è¡¨ç¤ºæ–¹å¼å¯¹æ¯”**:

| è¡¨ç¤ºæ–¹æ³• | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|------|------|---------|
| **ç‚¹äº‘** | ç²¾ç¡®,ä¿ç•™ç»†èŠ‚ | æ•°æ®é‡å¤§,å¤„ç†æ…¢ | 3Dæ„ŸçŸ¥,ç²¾ç¡®å»ºæ¨¡ |
| **æ …æ ¼åœ°å›¾** | è®¡ç®—ç®€å•,å†…å­˜è§„æ•´ | åˆ†è¾¨ç‡å—é™ | 2Då¯¼èˆª,è·¯å¾„è§„åˆ’ |
| **è¾¹ç•Œæ¡†** | è®¡ç®—æå¿« | è¿‡äºç®€åŒ– | å®æ—¶é¿éšœ,ç¢°æ’æ£€æµ‹ |
| **å¤šè¾¹å½¢** | ç²¾åº¦å¯è°ƒ | è®¡ç®—å¤æ‚åº¦ä¸­ç­‰ | å½¢çŠ¶æ‹Ÿåˆ,åŒºåŸŸè¡¨ç¤º |

**è¾¹ç•Œæ¡†è¡¨ç¤º**:

```mermaid
graph LR
    A[éšœç¢ç‰©] --> B[AABB<br/>è½´å¯¹é½åŒ…å›´ç›’]
    A --> C[OBB<br/>æ–¹å‘åŒ…å›´ç›’]
    A --> D[åœ†å½¢åŒ…å›´ç›’<br/>Bounding Circle]
    
    B --> E[ç¢°æ’æ£€æµ‹<br/>Collision Detection]
    C --> E
    D --> E
    
    style D fill:#e1f5ff
    style E fill:#ffe1f5
```

**ä»£ç å®ç°**:

```java
/**
 * éšœç¢ç‰©æŠ½è±¡ç±»
 */
public abstract class Obstacle {
    protected Point2D position;
    protected boolean isDynamic;
    
    /**
     * æ£€æŸ¥ä¸ç‚¹çš„ç¢°æ’
     */
    public abstract boolean intersects(Point2D point);
    
    /**
     * æ£€æŸ¥ä¸çº¿æ®µçš„ç¢°æ’
     */
    public abstract boolean intersects(Point2D start, Point2D end);
    
    /**
     * è·å–æœ€è¿‘ç‚¹çš„è·ç¦»
     */
    public abstract double distance(Point2D point);
}

/**
 * åœ†å½¢éšœç¢ç‰©(æœ€ç®€å•)
 */
public class CircularObstacle extends Obstacle {
    private double radius;
    
    @Override
    public boolean intersects(Point2D point) {
        return position.distance(point) <= radius;
    }
    
    @Override
    public boolean intersects(Point2D start, Point2D end) {
        // ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
        double dist = distancePointToSegment(position, start, end);
        return dist <= radius;
    }
    
    @Override
    public double distance(Point2D point) {
        return Math.max(0, position.distance(point) - radius);
    }
    
    /**
     * ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
     */
    private double distancePointToSegment(Point2D p, 
                                         Point2D a, Point2D b) {
        double vx = b.getX() - a.getX();
        double vy = b.getY() - a.getY();
        double wx = p.getX() - a.getX();
        double wy = p.getY() - a.getY();
        
        double c1 = wx * vx + wy * vy;
        if (c1 <= 0) {
            return p.distance(a);
        }
        
        double c2 = vx * vx + vy * vy;
        if (c1 >= c2) {
            return p.distance(b);
        }
        
        double b_proj = c1 / c2;
        Point2D projection = new Point2D.Double(
            a.getX() + b_proj * vx,
            a.getY() + b_proj * vy
        );
        
        return p.distance(projection);
    }
}

/**
 * çŸ©å½¢éšœç¢ç‰©
 */
public class RectangularObstacle extends Obstacle {
    private double width;
    private double height;
    private double orientation;  // æœå‘è§’
    
    @Override
    public boolean intersects(Point2D point) {
        // å°†ç‚¹è½¬æ¢åˆ°éšœç¢ç‰©å±€éƒ¨åæ ‡ç³»
        Point2D local = worldToLocal(point);
        return Math.abs(local.getX()) <= width / 2 && 
               Math.abs(local.getY()) <= height / 2;
    }
    
    private Point2D worldToLocal(Point2D world) {
        double dx = world.getX() - position.getX();
        double dy = world.getY() - position.getY();
        
        double cos = Math.cos(-orientation);
        double sin = Math.sin(-orientation);
        
        return new Point2D.Double(
            dx * cos - dy * sin,
            dx * sin + dy * cos
        );
    }
}
```

### æ¦‚å¿µ2:åŠ¨æ€çª—å£æ³•(Dynamic Window Approach)

**æ ¸å¿ƒæ€æƒ³**:åœ¨æœºå™¨äººåŠ¨åŠ›å­¦çº¦æŸä¸‹,æœç´¢æœ€ä¼˜çš„é€Ÿåº¦ç»„åˆ

**ç®—æ³•æµç¨‹**:

```mermaid
graph TB
    A[å½“å‰é€Ÿåº¦<br/>v, Ï‰] --> B[è®¡ç®—åŠ¨æ€çª—å£<br/>å¯è¾¾é€Ÿåº¦ç©ºé—´]
    B --> C[é‡‡æ ·é€Ÿåº¦å€™é€‰<br/>å¤šç»„v,Ï‰ç»„åˆ]
    C --> D{å¯¹æ¯ä¸ªå€™é€‰}
    D --> E[æ¨¡æ‹Ÿæœªæ¥è½¨è¿¹<br/>1-2ç§’]
    E --> F[è¯„ä¼°è½¨è¿¹<br/>ç›®æ ‡+éšœç¢+é€Ÿåº¦]
    F --> G[è®¡ç®—å¾—åˆ†]
    G --> H{éå†å®Œæˆ?}
    H -->|å¦| D
    H -->|æ˜¯| I[é€‰æ‹©æœ€é«˜åˆ†<br/>é€Ÿåº¦ç»„åˆ]
    I --> J[è¾“å‡ºæ§åˆ¶æŒ‡ä»¤]
    
    style I fill:#e1ffe1
```

**åŠ¨æ€çª—å£è®¡ç®—**:

```
åŠ¨åŠ›å­¦çº¦æŸ:
V_d = {(v, Ï‰) | v_min â‰¤ v â‰¤ v_max, Ï‰_min â‰¤ Ï‰ â‰¤ Ï‰_max}

åŠ é€Ÿåº¦çº¦æŸ:
V_a = {(v, Ï‰) | v-aÂ·Î”t â‰¤ v â‰¤ v+aÂ·Î”t, Ï‰-Î±Â·Î”t â‰¤ Ï‰ â‰¤ Ï‰+Î±Â·Î”t}

å®‰å…¨çº¦æŸ(é¿å…ç¢°æ’):
V_s = {(v, Ï‰) | dist(v,Ï‰) > stop_distance(v)}

åŠ¨æ€çª—å£ = V_d âˆ© V_a âˆ© V_s
```

**è¯„ä¼°å‡½æ•°**:

```
G(v, Ï‰) = ÏƒÂ·heading(v,Ï‰) + Î²Â·dist(v,Ï‰) + Î³Â·velocity(v,Ï‰)

å…¶ä¸­:
- heading: æœå‘ç›®æ ‡çš„ç¨‹åº¦
- dist: ä¸æœ€è¿‘éšœç¢ç‰©çš„è·ç¦»
- velocity: é€Ÿåº¦å¤§å°
- Ïƒ, Î², Î³: æƒé‡ç³»æ•°
```

**ä»£ç å®ç°**:

```java
/**
 * åŠ¨æ€çª—å£é¿éšœç®—æ³•
 */
public class DynamicWindowApproach {
    
    // å‚æ•°é…ç½®
    private double maxLinearVel = 0.5;    // æœ€å¤§çº¿é€Ÿåº¦ m/s
    private double maxAngularVel = 1.0;   // æœ€å¤§è§’é€Ÿåº¦ rad/s
    private double maxLinearAccel = 0.5;  // æœ€å¤§çº¿åŠ é€Ÿåº¦
    private double maxAngularAccel = 1.0; // æœ€å¤§è§’åŠ é€Ÿåº¦
    private double predictTime = 2.0;     // é¢„æµ‹æ—¶é—´
    private double timeStep = 0.1;        // æ¨¡æ‹Ÿæ—¶é—´æ­¥
    
    // è¯„ä¼°æƒé‡
    private double headingWeight = 1.0;
    private double distanceWeight = 0.5;
    private double velocityWeight = 0.2;
    
    /**
     * è®¡ç®—æœ€ä¼˜é€Ÿåº¦æŒ‡ä»¤
     */
    public VelocityCommand computeVelocity(
            Pose2D currentPose,
            VelocityCommand currentVel,
            Point2D goal,
            List<Obstacle> obstacles) {
        
        // 1. è®¡ç®—åŠ¨æ€çª—å£
        VelocityWindow window = calculateDynamicWindow(currentVel);
        
        // 2. é‡‡æ ·é€Ÿåº¦å€™é€‰
        List<VelocityCommand> candidates = sampleVelocities(window);
        
        // 3. è¯„ä¼°æ¯ä¸ªå€™é€‰
        VelocityCommand bestCmd = null;
        double bestScore = Double.NEGATIVE_INFINITY;
        
        for (VelocityCommand cmd : candidates) {
            // æ¨¡æ‹Ÿè½¨è¿¹
            Trajectory trajectory = simulateTrajectory(
                currentPose, cmd, predictTime
            );
            
            // æ£€æŸ¥ç¢°æ’
            if (isCollision(trajectory, obstacles)) {
                continue;  // è·³è¿‡ä¼šç¢°æ’çš„å€™é€‰
            }
            
            // è¯„ä¼°å¾—åˆ†
            double score = evaluateTrajectory(
                trajectory, goal, obstacles
            );
            
            if (score > bestScore) {
                bestScore = score;
                bestCmd = cmd;
            }
        }
        
        // 4. è¿”å›æœ€ä¼˜æŒ‡ä»¤(å¦‚æ— å®‰å…¨æŒ‡ä»¤åˆ™ç´§æ€¥åœæ­¢)
        return bestCmd != null ? bestCmd : 
               new VelocityCommand(0, 0);
    }
    
    /**
     * è®¡ç®—åŠ¨æ€çª—å£
     */
    private VelocityWindow calculateDynamicWindow(VelocityCommand current) {
        // åŠ¨åŠ›å­¦çº¦æŸ
        double vMin = 0;
        double vMax = maxLinearVel;
        double wMin = -maxAngularVel;
        double wMax = maxAngularVel;
        
        // åŠ é€Ÿåº¦çº¦æŸ
        double dt = 0.1;  // æ—¶é—´æ­¥
        vMin = Math.max(vMin, current.getLinear() - maxLinearAccel * dt);
        vMax = Math.min(vMax, current.getLinear() + maxLinearAccel * dt);
        wMin = Math.max(wMin, current.getAngular() - maxAngularAccel * dt);
        wMax = Math.min(wMax, current.getAngular() + maxAngularAccel * dt);
        
        return new VelocityWindow(vMin, vMax, wMin, wMax);
    }
    
    /**
     * é‡‡æ ·é€Ÿåº¦
     */
    private List<VelocityCommand> sampleVelocities(VelocityWindow window) {
        List<VelocityCommand> samples = new ArrayList<>();
        
        int vSamples = 10;
        int wSamples = 20;
        
        for (int i = 0; i < vSamples; i++) {
            double v = window.vMin + 
                      (window.vMax - window.vMin) * i / (vSamples - 1);
            
            for (int j = 0; j < wSamples; j++) {
                double w = window.wMin + 
                          (window.wMax - window.wMin) * j / (wSamples - 1);
                
                samples.add(new VelocityCommand(v, w));
            }
        }
        
        return samples;
    }
    
    /**
     * æ¨¡æ‹Ÿè½¨è¿¹
     */
    private Trajectory simulateTrajectory(Pose2D start, 
                                         VelocityCommand cmd, 
                                         double duration) {
        List<Pose2D> poses = new ArrayList<>();
        Pose2D current = start;
        
        for (double t = 0; t < duration; t += timeStep) {
            // ç®€åŒ–è¿åŠ¨å­¦æ¨¡å‹
            double x = current.getX() + 
                      cmd.getLinear() * Math.cos(current.getTheta()) * timeStep;
            double y = current.getY() + 
                      cmd.getLinear() * Math.sin(current.getTheta()) * timeStep;
            double theta = current.getTheta() + 
                          cmd.getAngular() * timeStep;
            
            current = new Pose2D(x, y, theta);
            poses.add(current);
        }
        
        return new Trajectory(poses);
    }
    
    /**
     * ç¢°æ’æ£€æµ‹
     */
    private boolean isCollision(Trajectory trajectory, 
                               List<Obstacle> obstacles) {
        for (Pose2D pose : trajectory.getPoses()) {
            for (Obstacle obs : obstacles) {
                if (obs.intersects(pose.getPosition())) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * è¯„ä¼°è½¨è¿¹
     */
    private double evaluateTrajectory(Trajectory trajectory, 
                                     Point2D goal, 
                                     List<Obstacle> obstacles) {
        Pose2D endPose = trajectory.getEndPose();
        
        // 1. æœå‘å¾—åˆ†:æœå‘ç›®æ ‡çš„ç¨‹åº¦
        double heading = calculateHeadingScore(endPose, goal);
        
        // 2. è·ç¦»å¾—åˆ†:ä¸éšœç¢ç‰©çš„æœ€å°è·ç¦»
        double distance = calculateDistanceScore(trajectory, obstacles);
        
        // 3. é€Ÿåº¦å¾—åˆ†:é¼“åŠ±è¾ƒé«˜é€Ÿåº¦
        double velocity = trajectory.getAverageVelocity() / maxLinearVel;
        
        return headingWeight * heading + 
               distanceWeight * distance + 
               velocityWeight * velocity;
    }
    
    /**
     * è®¡ç®—æœå‘å¾—åˆ†
     */
    private double calculateHeadingScore(Pose2D pose, Point2D goal) {
        double dx = goal.getX() - pose.getX();
        double dy = goal.getY() - pose.getY();
        double goalAngle = Math.atan2(dy, dx);
        
        double angleDiff = Math.abs(normalizeAngle(
            goalAngle - pose.getTheta()
        ));
        
        return 1.0 - angleDiff / Math.PI;  // [0, 1]
    }
    
    /**
     * è®¡ç®—è·ç¦»å¾—åˆ†
     */
    private double calculateDistanceScore(Trajectory trajectory, 
                                         List<Obstacle> obstacles) {
        double minDistance = Double.MAX_VALUE;
        
        for (Pose2D pose : trajectory.getPoses()) {
            for (Obstacle obs : obstacles) {
                double dist = obs.distance(pose.getPosition());
                minDistance = Math.min(minDistance, dist);
            }
        }
        
        // è·ç¦»è¶Šå¤§å¾—åˆ†è¶Šé«˜,ä½†æœ‰ä¸Šé™
        return Math.min(1.0, minDistance / 2.0);
    }
}
```

### æ¦‚å¿µ3:ç¢°æ’é¢„è­¦ç³»ç»Ÿ

**åˆ†çº§é¢„è­¦**:

| çº§åˆ« | è·ç¦»èŒƒå›´ | åŠ¨ä½œ | é¢œè‰²æ ‡è¯† |
|------|---------|------|---------|
| **å®‰å…¨** | > 1.0m | æ­£å¸¸è¡Œé©¶ | ğŸŸ¢ ç»¿è‰² |
| **è­¦å‘Š** | 0.5-1.0m | å‡é€Ÿ | ğŸŸ¡ é»„è‰² |
| **å±é™©** | 0.2-0.5m | æ€¥å‡é€Ÿ | ğŸŸ  æ©™è‰² |
| **ç´§æ€¥** | < 0.2m | ç´§æ€¥åœæ­¢ | ğŸ”´ çº¢è‰² |

**å®ç°**:

```java
/**
 * ç¢°æ’é¢„è­¦ç³»ç»Ÿ
 */
public class CollisionWarningSystem {
    
    private static final double SAFE_DISTANCE = 1.0;
    private static final double WARNING_DISTANCE = 0.5;
    private static final double DANGER_DISTANCE = 0.2;
    
    /**
     * è¯„ä¼°ç¢°æ’é£é™©
     */
    public CollisionRisk assessRisk(Pose2D robotPose, 
                                   VelocityCommand robotVel,
                                   List<Obstacle> obstacles) {
        double minDistance = Double.MAX_VALUE;
        Obstacle nearestObstacle = null;
        
        // æ‰¾åˆ°æœ€è¿‘çš„éšœç¢ç‰©
        for (Obstacle obs : obstacles) {
            double dist = obs.distance(robotPose.getPosition());
            if (dist < minDistance) {
                minDistance = dist;
                nearestObstacle = obs;
            }
        }
        
        // è®¡ç®—ç¢°æ’æ—¶é—´(TTC - Time To Collision)
        double ttc = calculateTTC(
            robotPose, robotVel, nearestObstacle
        );
        
        // ç¡®å®šé£é™©çº§åˆ«
        CollisionLevel level;
        if (minDistance >= SAFE_DISTANCE) {
            level = CollisionLevel.SAFE;
        } else if (minDistance >= WARNING_DISTANCE) {
            level = CollisionLevel.WARNING;
        } else if (minDistance >= DANGER_DISTANCE) {
            level = CollisionLevel.DANGER;
        } else {
            level = CollisionLevel.EMERGENCY;
        }
        
        return new CollisionRisk(level, minDistance, ttc, nearestObstacle);
    }
    
    /**
     * è®¡ç®—ç¢°æ’æ—¶é—´
     */
    private double calculateTTC(Pose2D pose, 
                               VelocityCommand vel, 
                               Obstacle obstacle) {
        if (obstacle == null) {
            return Double.MAX_VALUE;
        }
        
        // ç®€åŒ–:å‡è®¾ç›´çº¿è¿åŠ¨
        Point2D robotPos = pose.getPosition();
        Point2D obsPos = obstacle.getPosition();
        
        double dx = obsPos.getX() - robotPos.getX();
        double dy = obsPos.getY() - robotPos.getY();
        
        double vx = vel.getLinear() * Math.cos(pose.getTheta());
        double vy = vel.getLinear() * Math.sin(pose.getTheta());
        
        double relativeVel = (dx * vx + dy * vy) / 
                            Math.sqrt(dx * dx + dy * dy);
        
        if (relativeVel <= 0) {
            return Double.MAX_VALUE;  // è¿œç¦»éšœç¢ç‰©
        }
        
        double distance = obstacle.distance(robotPos);
        return distance / relativeVel;
    }
    
    /**
     * æ ¹æ®é£é™©è°ƒæ•´é€Ÿåº¦
     */
    public VelocityCommand adjustVelocity(VelocityCommand original, 
                                         CollisionRisk risk) {
        switch (risk.getLevel()) {
            case SAFE:
                return original;
                
            case WARNING:
                // å‡é€Ÿåˆ°70%
                return new VelocityCommand(
                    original.getLinear() * 0.7,
                    original.getAngular() * 0.7
                );
                
            case DANGER:
                // å‡é€Ÿåˆ°30%
                return new VelocityCommand(
                    original.getLinear() * 0.3,
                    original.getAngular() * 0.5
                );
                
            case EMERGENCY:
                // ç´§æ€¥åœæ­¢
                return new VelocityCommand(0, 0);
                
            default:
                return original;
        }
    }
}
```

### æ¦‚å¿µ4:äººå·¥åŠ¿åœºæ³•

**æ ¸å¿ƒæ€æƒ³**:ç›®æ ‡äº§ç”Ÿå¼•åŠ›,éšœç¢ç‰©äº§ç”Ÿæ–¥åŠ›

**åŠ¿åœºå‡½æ•°**:

```
å¸å¼•åŠ¿åœº(ç›®æ ‡):
U_att(q) = 1/2 Â· k_att Â· distanceÂ²(q, goal)

æ’æ–¥åŠ¿åœº(éšœç¢ç‰©):
U_rep(q) = {
    1/2 Â· k_rep Â· (1/d - 1/dâ‚€)Â²,  å¦‚æœ d < dâ‚€
    0,                            å¦‚æœ d â‰¥ dâ‚€
}

æ€»åŠ¿åœº:
U(q) = U_att(q) + Î£ U_rep_i(q)

åˆåŠ›:
F(q) = -âˆ‡U(q)
```

**ä»£ç å®ç°**:

```java
/**
 * äººå·¥åŠ¿åœºæ³•
 */
public class ArtificialPotentialField {
    private double k_att = 1.0;   // å¸å¼•åŠ›ç³»æ•°
    private double k_rep = 100.0; // æ’æ–¥åŠ›ç³»æ•°
    private double d0 = 1.0;      // éšœç¢ç‰©å½±å“èŒƒå›´
    
    /**
     * è®¡ç®—åˆåŠ›
     */
    public Vector2D calculateForce(Point2D position, 
                                   Point2D goal, 
                                   List<Obstacle> obstacles) {
        // å¸å¼•åŠ›
        Vector2D attractiveForce = calculateAttractiveForce(position, goal);
        
        // æ’æ–¥åŠ›
        Vector2D repulsiveForce = new Vector2D(0, 0);
        for (Obstacle obs : obstacles) {
            repulsiveForce = repulsiveForce.add(
                calculateRepulsiveForce(position, obs)
            );
        }
        
        return attractiveForce.add(repulsiveForce);
    }
    
    /**
     * å¸å¼•åŠ›
     */
    private Vector2D calculateAttractiveForce(Point2D position, 
                                             Point2D goal) {
        double dx = goal.getX() - position.getX();
        double dy = goal.getY() - position.getY();
        double distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 0.01) {
            return new Vector2D(0, 0);
        }
        
        // F_att = k_att * (goal - position)
        return new Vector2D(
            k_att * dx / distance,
            k_att * dy / distance
        );
    }
    
    /**
     * æ’æ–¥åŠ›
     */
    private Vector2D calculateRepulsiveForce(Point2D position, 
                                            Obstacle obstacle) {
        double distance = obstacle.distance(position);
        
        if (distance >= d0) {
            return new Vector2D(0, 0);
        }
        
        Point2D obsPos = obstacle.getPosition();
        double dx = position.getX() - obsPos.getX();
        double dy = position.getY() - obsPos.getY();
        
        // F_rep = k_rep * (1/d - 1/d0) * (1/dÂ²) * direction
        double magnitude = k_rep * (1.0/distance - 1.0/d0) / 
                          (distance * distance);
        
        return new Vector2D(
            magnitude * dx / distance,
            magnitude * dy / distance
        );
    }
}
```

**å±€é™æ€§**:
- å®¹æ˜“é™·å…¥å±€éƒ¨æœ€ä¼˜(å¦‚Uå½¢éšœç¢ç‰©)
- ç›®æ ‡é™„è¿‘æŒ¯è¡
- çª„é€šé“éš¾ä»¥é€šè¿‡

**æ”¹è¿›æ–¹æ³•**:
- ç»“åˆéšæœºæ‰°åŠ¨è·³å‡ºå±€éƒ¨æœ€ä¼˜
- ä½¿ç”¨æ”¹è¿›çš„åŠ¿åœºå‡½æ•°
- ä¸å…¨å±€è§„åˆ’ç»“åˆ

## æ€§èƒ½ä¼˜åŒ–

### ä¼˜åŒ–1:åˆ†å±‚æ£€æµ‹

```java
/**
 * åˆ†å±‚éšœç¢ç‰©æ£€æµ‹
 */
public class HierarchicalObstacleDetection {
    
    /**
     * ç²—æ£€æµ‹:å¿«é€Ÿæ’é™¤è¿œè·ç¦»éšœç¢ç‰©
     */
    public List<Obstacle> coarseDetection(Point2D position, 
                                         List<Obstacle> allObstacles) {
        List<Obstacle> nearby = new ArrayList<>();
        double threshold = 3.0;  // 3ç±³
        
        for (Obstacle obs : allObstacles) {
            if (obs.distance(position) < threshold) {
                nearby.add(obs);
            }
        }
        
        return nearby;
    }
    
    /**
     * ç²¾æ£€æµ‹:è¯¦ç»†ç¢°æ’æ£€æµ‹
     */
    public List<Obstacle> fineDetection(Trajectory trajectory, 
                                       List<Obstacle> candidates) {
        List<Obstacle> colliding = new ArrayList<>();
        
        for (Obstacle obs : candidates) {
            for (Pose2D pose : trajectory.getPoses()) {
                if (obs.intersects(pose.getPosition())) {
                    colliding.add(obs);
                    break;
                }
            }
        }
        
        return colliding;
    }
}
```

### ä¼˜åŒ–2:ç©ºé—´ç´¢å¼•

```java
/**
 * ä½¿ç”¨ç½‘æ ¼åŠ é€Ÿéšœç¢ç‰©æŸ¥è¯¢
 */
public class SpatialGrid {
    private Map<GridCell, List<Obstacle>> grid;
    private double cellSize;
    
    /**
     * å¿«é€ŸæŸ¥è¯¢é™„è¿‘éšœç¢ç‰©
     */
    public List<Obstacle> queryNearby(Point2D position, double radius) {
        Set<Obstacle> result = new HashSet<>();
        
        int minX = (int)((position.getX() - radius) / cellSize);
        int maxX = (int)((position.getX() + radius) / cellSize);
        int minY = (int)((position.getY() - radius) / cellSize);
        int maxY = (int)((position.getY() + radius) / cellSize);
        
        for (int x = minX; x <= maxX; x++) {
            for (int y = minY; y <= maxY; y++) {
                GridCell cell = new GridCell(x, y);
                List<Obstacle> obstacles = grid.get(cell);
                if (obstacles != null) {
                    result.addAll(obstacles);
                }
            }
        }
        
        return new ArrayList<>(result);
    }
}
```

## å¸¸è§é—®é¢˜

### é—®é¢˜1:DWAåœ¨çª„é€šé“ä¸­å¡ä½

**è§£å†³**:ä¸´æ—¶é™ä½å®‰å…¨è·ç¦»
```java
if (isNarrowPassage()) {
    distanceWeight = 0.2;  // é™ä½è·ç¦»æƒé‡
} else {
    distanceWeight = 0.5;  // æ­£å¸¸æƒé‡
}
```

### é—®é¢˜2:é«˜é€Ÿä¸‹æ¥ä¸åŠé¿éšœ

**è§£å†³**:é€Ÿåº¦è‡ªé€‚åº”
```java
double safeSpeed = Math.sqrt(2 * maxAccel * minObstacleDistance);
targetSpeed = Math.min(targetSpeed, safeSpeed);
```

## å°èŠ‚æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **éšœç¢ç‰©è¡¨ç¤º**:åœ†å½¢ã€çŸ©å½¢ã€å¤šè¾¹å½¢,æƒè¡¡ç²¾åº¦å’Œæ•ˆç‡
2. **DWAç®—æ³•**:åœ¨åŠ¨åŠ›å­¦çº¦æŸä¸‹æœç´¢æœ€ä¼˜é€Ÿåº¦
3. **ç¢°æ’é¢„è­¦**:åˆ†çº§é¢„è­¦,æå‰å“åº”
4. **åŠ¿åœºæ³•**:ç®€å•ç›´è§‚,ä½†æœ‰å±€éƒ¨æœ€ä¼˜é—®é¢˜
5. **æ€§èƒ½ä¼˜åŒ–**:åˆ†å±‚æ£€æµ‹ã€ç©ºé—´ç´¢å¼•

## æ€è€ƒé¢˜

1. **ç®—æ³•å¯¹æ¯”**:DWAå’ŒåŠ¿åœºæ³•å„é€‚ç”¨ä»€ä¹ˆåœºæ™¯?
2. **åŠ¨æ€éšœç¢ç‰©**:å¦‚ä½•é¢„æµ‹è¡Œäººçš„è¿åŠ¨è½¨è¿¹?
3. **å¤šæœºå™¨äºº**:å¤šä¸ªæœºå™¨äººå¦‚ä½•ååŒé¿éšœ?

## æ‹“å±•é˜…è¯»

- **DWAè®ºæ–‡**:The Dynamic Window Approach to Collision Avoidance
- **TEBç®—æ³•**:Timed Elastic Bandå±€éƒ¨è§„åˆ’
- **MPCæ–¹æ³•**:æ¨¡å‹é¢„æµ‹æ§åˆ¶ç”¨äºé¿éšœ

---

**ä¸‹ä¸€èŠ‚é¢„å‘Š**:ä¸‹ä¸€èŠ‚æˆ‘ä»¬å°†å­¦ä¹ è¦†ç›–è§„åˆ’ä¸æ¸…æ‰«ç­–ç•¥,äº†è§£å¦‚ä½•é«˜æ•ˆåœ°æ¸…æ‰«æ•´ä¸ªåŒºåŸŸã€‚
